// import { createSelector } from "reselect"




export const getUsersInfo = (state) => {
    return state.usersPage.userInfo
}

// Используем библиотеку reselect для создания сложных селекторов
// чтобы не вызывать ререндер и пересчет значений,  если не изменились свойства необходимые именно этому селектору


/*
    По стандарту при любом измении стейта(даже той части кторую мы не используем в нашей компоненте), вызывается функция mapStateToProps,
    внутри даной функции мы получаем по новому значения из стейта(даже если они не изменились) и сверяем их с предыдущими значениями, если что-то изменилось, то происходит перерендер.
    И это не проблема если мы импользуем примитивные селекторы, которые просто принимают стэйт и возвращают в компоненту полученые значения. Но если наш селектор сложный, то есть,
    перед тем как отправить данные в компоненту он выполняет какие-либо математические рассчеты, фильтрацию и т.д., то это довольно сильно влияет на производительность, и значительно
    усложняет дебагинг, так как при любом измении стэйта будет вызываться mapStateToProps и будут происходить перерасчеты, фильтрации и т.д.И соответственно при использовании дебагинга
    могут возникнуть проблемы, так как мы будем постоянно попадать в дебагер даже если необходимые данные из стейта не изменились.

    Для исправления таких проблем существует библиотека reselect, которая позволяет создать селектор и установить для него зависимости. Зависимости позволяют выполнять перерассчеты
    внутри сложного селектора, только при изменении самих же зависимостей. В качесте зависимостей зачастую выступают простые селекторы. 

    Например, у нас есть простой селектор который из стейта получает информацию о всех пользователях и имеет название getUsersInfo.
    А нам в нашей компоненте необходимо получить только тех пользователей которые прошли фильтрацию по какому-либо свойству, например возрасту. Тут нам на помощь приходит 
    сложный селектор getUsersInfoAge, внутри которого при помощи зависимости в виде селектора(getUsersInfo) мы получаем сначала информацию о всех пользователях, после чего 
    отфильтровываем их по возрасту и возвращаем нашей компоненте. Данная фильтрация будет происходить только при первой загрузке компоненты
    (то есть когда у нас еще нет предыдущего значения getUsersInfo) и при изменении значения getUsersInfo, во всех остальных случаях перерасчёт происходить не будет.
*/

// export const getUserInfoSuper = createSelector(getUsersInfo,getIsFetching, (usersInfo, isFetching) => {
//     return usersInfo.filter(i => true)
// })
export const getPageSize = (state) => {
    return state.usersPage.pageSize
}
export const getTotalUsersCount = (state) => {
    return state.usersPage.totalUsersCount
}
export const getCurentPage = (state) => {
    return state.usersPage.curentPage
}
export const getIsFetching = (state) => {
    return state.usersPage.isFetching
}
export const getFollowingInProgress = (state) => {
    return state.usersPage.followingInProgress
}
export const getIsFollowed = (state) => {
    return state.usersPage.isFollowed
}
export const getSearchInputValue = (state) => {
    return state.usersPage.searchInputValue
}
